/**
 ****************************************************************************************
 *
 * @file optek_link_commons.c
 *
 * @brief optek link commons.
 *
 ****************************************************************************************
 */

#include "os_config.h"

#include "sdk_com.h"

#include "bt_def.h"
#include "bluetooth.h"
#include "hci.h"
#include "hci_core.h"
#include "app_bt_tx.h"
#include "ht_hci_main.h"
#include "bt_lib_mask.h"
#include "bt_common.h"

#include "btdm_task.h"
#include "interrupt.h"
#include "hw_timer.h"
#include "hal_uart.h"
#include "hw_timer.h"
#include "fifo.h"
#include "audio_com.h"

#include "optek_link_commons.h"
#include "mem_reloc.h"
#include "hal_sflash.h"
#include "window.h"

#ifdef OPTEK_LINK_ENABLE
#define OPTEK_LINK_FUNC_ENABLE
#endif

U8 optek_link_default_role_get(void);

OPL_STATUS_s opl_status;

U8 optek_link_mode;

u8 master_bdaddr[6];
U8 conn_rej_count;

//in one group, the device can opterate together, should be generated by random
const u8 optek_link_group[3] = {0x3F,0xc5,0x67};
//const u8 optek_link_group[3] = {'S',0x01,0x01};
//const u8 optek_link_group[3] = {'P',0x00,0x01};
//const u8 optek_link_group[3] = {'A',0x00,0x00};
//const u8 optek_link_group[3] = {'C',0x02,0x02};

extern U8 OPTEK_LINK_USER_DATA[];

#define OPTEK_LINK_USER_DATA_FLASH_ADDR OPTEK_LINK_USER_DATA

typedef struct {
	U8 master_bdaddr[6];
	U8 opl_role;
} OPTEK_LINK_USER_DATA_STRU;

//#define FIXED_TX_ADDR

#ifdef FIXED_TX_ADDR
extern const u8 tx_bdaddr[6];

void optek_link_set_master_bdaddr(u8 *bdaddr)
{
	printf_info("set master bdaddr:%m\n", bdaddr);
#if 0	
	U32 addr;
	
	addr = (U32)ROM_SAVE_DATA2_START;
	app_flash_program_user_data(addr, (U32 *)mac_id, 8);
#endif
}

u8* optek_link_get_master_bdaddr(void)
{
	return tx_bdaddr;
//	return ROM_SAVE_DATA2_START;
}

U8 optek_link_master_bdaddr_is_present(void)
{
	return TRUE;
#if 0
	u8 *mac_id = ROM_SAVE_DATA2_START;

	DBG_Printf("mac_id[3] =0x%x,mac_id[4] =0x%x,mac_id[5] =0x%x\r\n",mac_id[3],mac_id[4],mac_id[5]);

	if(mac_id[3] == 0x3F && mac_id[4] == 0x9F && mac_id[5] == 0x94)
		return TRUE;
	else
		return FALSE;
#endif
}

#else

void optek_link_set_master_bdaddr(u8 *bdaddr)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
	OPTEK_LINK_USER_DATA_STRU user_data;

	memcpy(user_data.master_bdaddr, bdaddr, sizeof(user_data.master_bdaddr));
	user_data.opl_role = global_vari.optek_link_role;

	printf_info("set master bdaddr:%m\n", bdaddr);
	hal_sflash_write(OPTEK_LINK_USER_DATA_FLASH_ADDR, (U32 *)&user_data, sizeof(user_data));
	#endif
}

u8* optek_link_get_master_bdaddr(void)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
	OPTEK_LINK_USER_DATA_STRU *user_data = OPTEK_LINK_USER_DATA_FLASH_ADDR;
	printf_info("get master bdaddr:%m\n", user_data->master_bdaddr);
	return user_data->master_bdaddr;
	#else
	return NULL;
	#endif
}

U8 optek_link_master_bdaddr_is_present(void)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
	OPTEK_LINK_USER_DATA_STRU *user_data = OPTEK_LINK_USER_DATA_FLASH_ADDR;
	u8 *bdaddr = user_data->master_bdaddr;

	//DBG_Printf("mac_id[3] =0x%x,mac_id[4] =0x%x,mac_id[5] =0x%x\r\n",mac_id[3],mac_id[4],mac_id[5]);

	if(bdaddr[3] == 0x3F && bdaddr[4] == 0x9F && bdaddr[5] == 0x94)
		return TRUE;
	else
		return FALSE;
	#else
	return FALSE;
	#endif
}

#endif

void optek_link_set_role(U8 role)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
	int offset = offsetof(OPTEK_LINK_USER_DATA_STRU, opl_role);

	//printf_info("offset:%d\n", offset);

	hal_sflash_write(OPTEK_LINK_USER_DATA_FLASH_ADDR+offset, (U8 *)&role, sizeof(role));
	#endif
}

U8 optek_link_get_role(void)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
	OPTEK_LINK_USER_DATA_STRU *user_data = OPTEK_LINK_USER_DATA_FLASH_ADDR;
	
	return user_data->opl_role;
	#else
	return 0;
	#endif
}

U8 optek_link_get_role_w_check(void)
{
	U8 role;

#ifdef OPTEK_LINK_ENABLE
	int i;
	U8 role_count = sw_role_info.table_size;

	role = optek_link_get_role();

	if (role_count)
	{
		for (i=0;i<role_count;i++)
		{
			if (role == sw_role_info.sw_role_table[i])
			{
				break;
			}
		}

		if (i == role_count)
		{
			role = optek_link_default_role_get();//default role when first burn, see @sw_role_table
		}
	} 
	else
	{
		role = nonOPL_ROLE;
	}	

	#if 0//for fixed role, todo
	role = OPL_ROLE_SLAVE;
	role = OPL_ROLE_SLAVE2;
	role = OPL_ROLE_MASTER;
	#endif

#else
	role = nonOPL_ROLE;
#endif

	switch (role)
	{
	case OPL_ROLE_MASTER:
		printf_info("optek link master\n");
		break;
	case OPL_ROLE_SLAVE:
		printf_info("optek link slave\n");
		break;
	case OPL_ROLE_SLAVE2:
		printf_info("optek link slave2\n");
		break;
	case nonOPL_ROLE:
		printf_info("optek link diable\n");
		break;
	default:
		printf_info("unknown optek link role!\n");
		break;
	}

	return role;
}

U8 optek_link_is_slave(void)
{
	return (global_vari.optek_link_role == OPL_ROLE_SLAVE || global_vari.optek_link_role == OPL_ROLE_SLAVE2);
}

U8 optek_link_is_master(void)
{
	return (global_vari.optek_link_role == OPL_ROLE_MASTER);	
}

U8 optek_link_is_disable(void)
{
	return (global_vari.optek_link_role != OPL_ROLE_SLAVE && global_vari.optek_link_role != OPL_ROLE_SLAVE2 && global_vari.optek_link_role != OPL_ROLE_MASTER);	
}

/**
 ****************************************************************************************
 * @brief initialize timer 1 use for optek link rx timer
 *
 ****************************************************************************************
 */
void hw_timer_1_init(U32 tick_per_sec)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
	u16 val_16b;
	TIMER_CTRLs *pTimer_cntl = &val_16b;
	TIMER_IDEL_LEV_INT_MASKs *pTimer_int_mask = &val_16b;

	if (tick_per_sec == 0)
	{
		ADDR_TIMER_1_VAL = 0;//disable
		val_16b = ADDR_TIMER_IDLE_LEV;
		pTimer_int_mask->timer_1_int_mask = 1;
		ADDR_TIMER_IDLE_LEV = val_16b;

		val_16b = ADDR_TIMER_CTRL;
		pTimer_cntl->timer_1_en = 0;
		ADDR_TIMER_CTRL = val_16b;
	}
	else
	{
		ADDR_TIMER_1_VAL = (TIMERs_BASE_CLK_HZ / tick_per_sec + 1);

		val_16b = ADDR_TIMER_IDLE_LEV;
		pTimer_int_mask->timer_1_int_mask = 1;
		ADDR_TIMER_IDLE_LEV = val_16b;

		val_16b = ADDR_TIMER_CTRL;
		pTimer_cntl->timer_1_en = 1;
		ADDR_TIMER_CTRL = val_16b;
	}
/*
	hal_gpio_mux_func_select(GPIO0_30_INDEX, MUX_SEL_GPIO_OUTPUT);
	hal_gpio_output_level_set(GPIO0_30_INDEX, GPIO_LOW);
	hal_gpio_mux_func_select(GPIO0_29_INDEX, MUX_SEL_GPIO_OUTPUT);
	hal_gpio_output_level_set(GPIO0_29_INDEX, GPIO_LOW);
*/
	xt_ints_on(LEVEL2_INT20_MASK);
	#endif
}

/*unit is 0.5us*/
void optek_link_timer_set(U32 hus) __INTERNAL_RAM_TEXT;
void optek_link_timer_set(U32 hus)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
	u16 val_16b;
	TIMER_CTRLs *pTimer_cntl = &val_16b;
	TIMER_IDEL_LEV_INT_MASKs *pTimer_int_mask = &val_16b;

	// val_16b = ADDR_TIMER_CTRL;
	// pTimer_cntl->timer_1_en = 0;
	// ADDR_TIMER_CTRL = val_16b;
	
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");
	// asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");

	ADDR_TIMER_1_VAL = hus * TIMERs_BASE_Hus_TICK;	

	val_16b = ADDR_TIMER_CTRL;
	pTimer_cntl->timer_1_en = 1;
	ADDR_TIMER_CTRL = val_16b;

	//REG_GPIO0_DOUT |= (0x01 << 29); 
	//REG_GPIO0_DOUT &= ~(0x01 << 29); 

	REG_GPIO1_IE = 0;//this is a patch
	#endif
}

void optek_link_timer_disable(void) __INTERNAL_RAM_TEXT;
void optek_link_timer_disable(void)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
	u16 val_16b;
	TIMER_CTRLs *pTimer_cntl = &val_16b;
	TIMER_IDEL_LEV_INT_MASKs *pTimer_int_mask = &val_16b;

	val_16b = ADDR_TIMER_CTRL;
	pTimer_cntl->timer_1_en = 0;
	ADDR_TIMER_CTRL = val_16b;

	REG_GPIO1_IE = 0;//this is a patch
	#endif
}


void _optek_link_timer_set(U32 hus) __INTERNAL_RAM_TEXT;
void _optek_link_timer_set(U32 hus)
{


}

void L2_int20_optek_link_rx_timer_handler(void *param) __INTERNAL_RAM_TEXT;
void L2_int20_optek_link_rx_timer_handler(void *param)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
	u16 val_16b;
	TIMER_CTRLs *pTimer_cntl = &val_16b;
	TIMER_IDEL_LEV_INT_MASKs *pTimer_int_mask = &val_16b;
	TIMER_INT_CLRs *pTime_int_clr = &val_16b;

	#ifdef SAVE_MODULE_FROM_FLASH
	sflash_in_programming_check();
	#endif

	//REG_GPIO0_DOUT |= (0x01 << 30); 
	//REG_GPIO0_DOUT &= ~(0x01 << 30); 

	val_16b = ADDR_TIMER_INT_CLR;
	pTime_int_clr->timer_1_int_clr = 1;
	ADDR_TIMER_INT_CLR = val_16b;

	val_16b = ADDR_TIMER_CTRL;
	pTimer_cntl->timer_1_en = 0;
	ADDR_TIMER_CTRL = val_16b;

	//optek_link_timer_int();

	REG_GPIO1_IE = 0;//this is a patch
	#endif	
}

/*
 * optek link initialization and stop 
 ****************************************************************************************
 */
uint8_t optek_link_act_id;
void optek_link_role_stop(void)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
	if (opl_status.opl_main_status != enOPL_CLOSED)
	{
		DBG_Printf("optek_link_role_stop\n\r");
		opl_status.opl_main_status = enOPL_CLOSING;
		kBtHCI_optek_link_enable(0, OPTEK_LINK_H1);
		delayms(100);//wait stop complete
		opl_status.opl_main_status = enOPL_CLOSED;
	}
	#endif
}

void optek_link_end_cb(u8 id) __attribute__ ((section (".internal_ram_1_text")));  
void optek_link_end_cb(u8 id)
{
/*    
    DBG_Assert (0);
    debug_pin_high();
    debug_pin_low();    
    uikMsgSend (optek_link_end);
*/
}

extern U8 req_mode, req_txlen, req_rxlen;
static void optek_link_master_enable(U32 sample_rate)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
	u8 succ;
	struct optek_link_setting_tag optek_link_setting_s;
	memset (&optek_link_setting_s,0,sizeof(optek_link_setting_s));

	DBG_Printf("optek link master enable\n\r");
	
	#ifdef OPL_MODE_TWO_WAY_LONG_DISTANCE
	set_skip_cnt_in_non_conn(0);//disable skip because there have listening headphones
	#else
	set_skip_cnt_in_non_conn(0xff);//0xff means skip count is determined by lib
	#endif
	
	optek_link_setting_s.role = OPTEK_LINK_MASTER;

	optek_link_setting_s.mode = req_mode;
	optek_link_setting_s.max_rx_len = req_rxlen;
	optek_link_setting_s.max_tx_len = req_txlen;


	optek_link_setting_s.btaddr = NULL;												//for master role
	optek_link_setting_s.link_group = optek_link_group;
	optek_link_setting_s.window = 0;
	optek_link_setting_s.interval = 0;
	optek_link_setting_s.tx_power = OPTEK_LINK_POWER;
	optek_link_setting_s.paring_power = OPTEK_LINK_PARING_POWER;		

	optek_link_setting_s.max_multi_rx_len = NULL;

	optek_link_setting_s.logic_addr = LOGIC_ADDR_DYNAMIC;
	optek_link_setting_s.slave_rx_all = 1;
	optek_link_setting_s.rx_skip_disable = 0;
			
	succ = optek_link_set (&optek_link_setting_s, OPTEK_LINK_H1);			
	DBG_Assert (succ == 1);
	
	if (succ)
	{
		succ = kBtHCI_optek_link_enable(1, OPTEK_LINK_H1);			
	}

	optek_link_mode = optek_link_setting_s.mode;
	delayms(10);
	succ = optek_link_set_master_paring(1, 2, 0, OPTEK_LINK_H1);				//enable master paring, 1/2, forever
	DBG_Assert (succ == 1);
	#endif
}

static void optek_link_slave_enable(U8 role)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
	u8 succ,i;
	struct optek_link_setting_tag optek_link_setting_s;
	memset (&optek_link_setting_s,0,sizeof(optek_link_setting_s));

	DBG_Printf("optek link slave enable,role:%d\n\r",role);

	if(optek_link_master_bdaddr_is_present() || role == OPTEK_LINK_SCAN)
	{
		//optek_link_role_stop();
		//delayms(30);

		#define TRY_COUNT 3

		for (i=0;i<TRY_COUNT;i++)
		{
			if (role == OPTEK_LINK_SLAVE)
			{
				conn_rej_count = 1;
				memcpy (master_bdaddr, optek_link_get_master_bdaddr(),6);															//for slave and scan role
				optek_link_setting_s.btaddr = master_bdaddr;											//for slave role
				optek_link_setting_s.max_rx_len = 90;//100;	
				optek_link_setting_s.max_tx_len = 50;
				optek_link_setting_s.max_multi_rx_len = NULL;
				#ifdef SLAVE_ONLY_LISTENING
				optek_link_setting_s.logic_addr = 0;//LOGIC_ADDR_DYNAMIC;
				#else
				#if (defined OPL_MODE_THREE_WAY || defined OPL_MODE_THREE_WAY_HIGH_QUALITY || defined OPL_MODE_MICx2 || defined OPL_MODE_MICx2_HIGH_QUALITY)
				optek_link_setting_s.logic_addr = LOGIC_ADDR_DYNAMIC;
				#else
				if (global_vari.optek_link_role == OPL_ROLE_SLAVE)
					optek_link_setting_s.logic_addr = 1;//;
				else
					optek_link_setting_s.logic_addr = 2;//;
				#endif
				#endif
				optek_link_setting_s.slave_rx_all = 1;
				optek_link_setting_s.rx_skip_disable = 0;

			}

			optek_link_setting_s.role = role;

			optek_link_setting_s.mode = 0;

			optek_link_setting_s.link_group = optek_link_group;
			optek_link_setting_s.window = 56;
			optek_link_setting_s.interval = 64;
			
			optek_link_setting_s.tx_power = OPTEK_LINK_POWER;
			optek_link_setting_s.paring_power = OPTEK_LINK_PARING_POWER;		
		
			optek_link_setting_s.max_multi_rx_len = NULL;			


			if (optek_link_set (&optek_link_setting_s, OPTEK_LINK_H1))
			{
				if (kBtHCI_optek_link_enable(1, OPTEK_LINK_H1))
				{
					break;
				}
				else
				{
					delayms(200);
					DBG_Printf("enable fail,try again\n\r");
				}
			}
			else
			{
				delayms(200);
				DBG_Printf("setting fail,try again\n\r");
			}
		}

		if (i < TRY_COUNT)
		{
			DBG_Printf("enable success\n\r");			
			opl_status.opl_main_status = enOPL_OPENED;
		}
		else
		{
			DBG_Printf("enable fail\n\r");
			opl_status.opl_main_status = enOPL_CLOSED;
		}

		//delayms(1000);
	}
	else
	{
		DBG_Printf("not paired with any master\n\r");//here can enter pairing mode if need
	}	
	#endif
}

void optek_link_open(void)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
	xt_set_interrupt_handler(20, L2_int20_optek_link_rx_timer_handler, NULL);
	hw_timer_1_init(0);

	if (optek_link_is_master())
	{
		if (opl_status.opl_main_status == enOPL_CLOSED)
		{
			optek_link_master_enable(48000);
			opl_status.opl_main_status = enOPL_OPENED;
		}		
	}
	else if (optek_link_is_slave())
	{
		if (opl_status.opl_main_status == enOPL_CLOSED)
		{
			optek_link_slave_enable(OPTEK_LINK_SLAVE); 
			//optek_link_slave_enable(OPTEK_LINK_SCAN);
			//opl_status.opl_main_status = enOPL_OPENED;
		}		
	}
	#endif

}

void app_optek_link_init(void)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
	DBG_Printf("optek link ver:%s,build time:%s %s\r\n",optek_link_version_get(),optek_link_time_get(),optek_link_data_get());

	//DBG_Printf("lc3 cedec ver:%s\r\n",xa_lc3_get_lib_version_string());

	opl_status.opl_main_status = enOPL_CLOSED;
	#endif
}

void app_optek_link_open(void)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
	optek_link_mode_init();

	optek_link_open();
	#endif
}

/*
 * change mode interface
 ****************************************************************************************
 */
U8 req_mode,req_txlen,req_rxlen;
void app_change_mode_check(void)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
	#ifdef OPL_MASTER_ENABLE
	//change mode req check
	if (opl_status.opl_main_status != enOPL_CLOSED)
	{
		if ((req_mode != optek_link_mode)&&(global_vari.optek_link_role == OPL_ROLE_MASTER))
		{
			optek_link_change_mode(req_mode,req_txlen,req_rxlen,OPTEK_LINK_H1);
			optek_link_mode = req_mode;

			//if (spk_out_sync_w_tx_status != SPK_AND_TX_NOTSYNC)
			{
				//spk_out_sync_w_tx_status = SPK_AND_TX_SYNCING;
			}
		}
	}
	#endif
	#endif
}

void app_change_mode_req(u8 mode, u8 max_master_tx_len, u8 max_master_rx_len)
{	
	#ifdef OPTEK_LINK_FUNC_ENABLE
	req_mode = mode;
	req_txlen = max_master_tx_len;
	req_rxlen = max_master_rx_len;
	#endif
}

void app_sw_mode(void)
{
#if 0
	static U8 mode;

	app_cmd_DecoderExit();

	if (mode)
	{
		app_change_mode_req(BC_SF48K_PT5MS,100,6);
	}
	else
	{
		app_change_mode_req(GAME_HEADPHONE_PT_5MS_LP,100,50);
	}
	mode = !mode;

	app_media_mute_disable();
	uDecSend (DECODE_INIT, NULL); 
	spk_out_sync_w_tx_status = SPK_AND_TX_SYNCING;
#endif
}

/*
 * pairing 
 ****************************************************************************************
 */

void app_nav_optek_link_pairing(void)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
	u8 succ;
	struct optek_link_setting_tag optek_link_setting_s;
	memset (&optek_link_setting_s,0,sizeof(optek_link_setting_s));

	if (optek_link_is_master())
	{	
		if (opl_status.opl_main_status != enBT_CLOSED)
		{
			U8 percentage = 2;// 1/percentage
			U16 time = 4000;// unit is packet time

			DBG_Printf("Master start pairing,\npercentage:1/%d,\npairing time:%d packet\n\r",percentage,time);
			succ = optek_link_set_master_paring(1, percentage, time, OPTEK_LINK_H1); 			//enable master paring, 1/2, 5s			
		}
		else
		{
			DBG_Printf("optek link is not enabled!pls enable it first!\r\n");
		}
	}
	else if(optek_link_is_slave())
	{
		DBG_Printf("slave start pairing\r\n");

		//app_dac_receive_pcm_enable(FALSE);
		//app_nav_bt_codec_reinit();
		optek_link_role_stop();
		if (opl_status.opl_main_status == enOPL_CONNECTED)
		{
			optek_link_slave_link_loss_cb();
		}	
		delayms(100);

		optek_link_slave_enable(OPTEK_LINK_SCAN);
		//opl_status.opl_main_status = enOPL_OPENED;
/*
		optek_link_setting_s.role = OPTEK_LINK_SCAN;

		optek_link_setting_s.mode = 0;													//for slave and scan role
		
		optek_link_setting_s.btaddr = NULL;												//for master role
		optek_link_setting_s.link_group = optek_link_group;
		optek_link_setting_s.window = 48;
		optek_link_setting_s.interval = 64;
		optek_link_setting_s.tx_power = OPTEK_LINK_POWER;
		optek_link_setting_s.paring_power = OPTEK_LINK_PARING_POWER;		
		optek_link_setting_s.max_rx_len = 0;										

		optek_link_setting_s.max_multi_rx_len = NULL;
				
		succ = optek_link_set (&optek_link_setting_s, OPTEK_LINK_H1);			
		DBG_Assert (succ == 1);
		
		if (succ)
			succ = kBtHCI_optek_link_enable(1, OPTEK_LINK_H1);

		DBG_Assert (succ == 1); 
*/
	}
	#endif
}

VOID_FUNC_TO_KEY_HANDLER(app_nav_optek_link_pairing);

static void optek_link_pairing_closed_notify(void)
{
	DBG_Printf("master Pairing has been closed\r\n");
}

void optek_link_master_paring_end_cb(void) __attribute__ ((section (".internal_ram_1_text")));
void optek_link_master_paring_end_cb(void)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
	func_wo_param_msgSend_formIsr(optek_link_pairing_closed_notify);
	#endif
}

static void optek_link_search_end (void)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
	u8 succ;
	struct optek_link_setting_tag optek_link_setting_s;
	memset (&optek_link_setting_s,0,sizeof(optek_link_setting_s));

	DBG_Printf("OPTEK link search end\n\r");

	optek_link_role_stop();
	delayms(50);	
	optek_link_set_master_bdaddr(master_bdaddr);

	DBG_Printf("master mac id:%m\n\r", master_bdaddr);

	optek_link_slave_enable(OPTEK_LINK_SLAVE);
	//opl_status.opl_main_status = enOPL_OPENED;
	//spk_out_sync_w_tx_status = SPK_AND_TX_SYNCING;	
	#endif
}

U8 optek_link_paring_end_cb(u8 *m_btaddr,U8 mode, uint8_t act_id) __attribute__ ((section (".internal_ram_1_text")));
U8 optek_link_paring_end_cb(u8 *m_btaddr,U8 mode, uint8_t act_id)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
	optek_link_act_id = act_id;

	//DBG_iPrintf("act id:%d\n\r", optek_link_act_id);
	//DBG_Assert(act_id == 0);
	//return TRUE;
	//if (mode == MULTI_MICx3_SF24K_PT10MS)
	{
		//optek link 2.0 wo company id
		memcpy (master_bdaddr, m_btaddr, 3);
		//optek company id, please note if comnpany id changed, the followwing should be changed
		master_bdaddr[3] = 0x3f;
		master_bdaddr[4] = 0x9f;
		master_bdaddr[5] = 0x94;

		func_wo_param_msgSend_formIsr(optek_link_search_end);

		return TRUE;
	}
/*	else
	{
		return FALSE;
	}*/

	#endif
}

/*
 * role contrrol
 ****************************************************************************************
 */
U8 optek_link_default_role_get(void)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
	if (sw_role_info.table_size != 0)
	{
		return sw_role_info.sw_role_table[0];
	}
	else
	{
		return nonOPL_ROLE;
	}
	#endif
}

U8 get_optek_link_next_role(U8 curr_role)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
	int i;
	U8 role_count = sw_role_info.table_size;

	if (role_count)
	{
		for (i=0;i<role_count;i++)
		{
			if (curr_role == sw_role_info.sw_role_table[i])
			{
				break;
			}
		}

		if (i != role_count)
		{
			i++;//next source
			i %= role_count;
			return sw_role_info.sw_role_table[i];
		}
		else
		{
			DBG_Printf("err:current role id:%d is not in role table! return default role id\r\n",curr_role);			
			return optek_link_default_role_get();
		}
	} 
	else
	{
		DBG_Printf("role table is null\r\n");			
		return optek_link_default_role_get();
	}
	#endif
}

extern U8 sram_boot_config[16];
/* note that this function only run in keyfunction task */
void app_optek_link_role_sw(void)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
	U8 next_role_id = get_optek_link_next_role(global_vari.optek_link_role);

	if (next_role_id == global_vari.optek_link_role)
	{
		printf_info("fix role, no anther role to switch\n");
		return;
	}

	if (global_vari.optek_link_role != nonOPL_ROLE)
	{
		//app_dac_receive_pcm_enable(FALSE);
		//decode_exit_wait_forever_msgSend();
		//optek_link_role_stop();	

		optek_link_set_role(next_role_id);
	}
	else if (global_vari.optek_link_role == OPL_ROLE_MASTER)
	{
		decode_exit_wait_forever_msgSend();
		optek_link_role_stop();
					
		optek_link_set_role(next_role_id);
	}
	else if (global_vari.optek_link_role == nonOPL_ROLE)
	{
		if (hci_A2DP_conn_present() == TRUE)
		{
			bt_hci_flush();
			delayms(200);
		}

		#ifdef BTDM52_ENABLE
		app_bt_set_scan_enable_mode(enBT_BOTH_SCAN_DISABLE);
		#endif
		delayms(100);
		
		optek_link_set_role(next_role_id);
	}
	else
	{
		optek_link_set_role(optek_link_default_role_get());
	}

	switch (next_role_id)
	{
	case OPL_ROLE_MASTER:
		printf_info("swtich to master\n");
		break;
	case OPL_ROLE_SLAVE:
		printf_info("swtich to slave\n");
		break;
	case OPL_ROLE_SLAVE2:
		printf_info("swtich to slave2\n");
		break;
	case nonOPL_ROLE:
		printf_info("swtich to normal bt\n");
		break;
	default:
		DBG_Assert(FALSE);
		break;
	}
	delayms(100);//wait for print

	memset(sram_boot_config,0,sizeof(sram_boot_config));
	CPU_SoftReset_Flag_Setting((U8 *) sram_boot_config, TRUE);	
	#endif
}

VOID_FUNC_TO_KEY_HANDLER(app_optek_link_role_sw);


/*
 * hopping chan table
 ****************************************************************************************
 */

/*
#define OPTEK_LINK_HOPPING_CH 37
#define OPTEK_LINK_MAX_CH 37
const u8 optek_link_scan_chan[OPTEK_LINK_MAX_CH] =
{
    0,  1,  2,  3,  4,  5,  6,  7,
    8,  9,  10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, 28, 29, 30, 31,
    32, 33, 34, 35, 36
};
*/

/*
please note OPTEK_LINK_HOPPING_CH should not equal to total_slots x N
*/


#define OPTEK_LINK_HOPPING_CH    5
#define OPTEK_LINK_MAX_CH        5

const u8 optek_link_scan_chan[OPTEK_LINK_MAX_CH] =
{
    //1,2 
    //1,2,11 
    //1,2,11,12 
    1,2,11,12,13 
};


/*
#define OPTEK_LINK_HOPPING_CH    11
#define OPTEK_LINK_MAX_CH       11

const u8 optek_link_scan_chan[OPTEK_LINK_MAX_CH] =
{
    //1,2,3
	//0,1,2
    //2,3 
    //0,1,2,3,11,12,13,15,32,33,31 			//ok
    //4,5,6,3,11,12,13,15,32,33,31 			//ok
    //4,5,6,2,11,12,13,15,32,33,31 			//ng
    //4,5,6,1,11,12,13,15,32,33,31 			//ng			
    //4,5,6,0,11,12,13,15,32,33,31 			//ok

    4,5,6,21,22,23,13,15,32,33,31 			//ok


	//4,5,6,21,22,23,13,15,32,33,31
    //1,2,11,12 
    //1,2,11,12,13 
};
*/

/*
#define OPTEK_LINK_HOPPING_CH    28
#define OPTEK_LINK_MAX_CH       28

//please note wifi 2.4g channel 11 center frequsncy is 2462, try to avoid. These channels can be masked by dynamic hoppong mask setting based on real application
const u8 optek_link_scan_chan[OPTEK_LINK_MAX_CH] =
{
	0,1,2,3,4,
	5,6,7,8,9,
	10,11,12,13,14,
	15,16,17,18,19,
	20,21,22,23,33,
	34,35,36
};
*/



// for philips
/*
#define OPTEK_LINK_HOPPING_CH 8
#define OPTEK_LINK_MAX_CH 8
const u8 optek_link_scan_chan[OPTEK_LINK_MAX_CH] =
{
    0,  1,  31,  32,  33,  34,  35,  36,
};
*/

/*
#define OPTEK_LINK_HOPPING_CH 8
#define OPTEK_LINK_MAX_CH 8
const u8 optek_link_scan_chan[OPTEK_LINK_MAX_CH] =
{
    9,  10,  21,  22,  33,  34,  35,  36,
};
*/


#define OPTEK_LINK_PAIRING_MAX_CH   6				//define same in optek_link.c, maxis 6
//should exclude from normal optek_link_scan_chan
const uint8_t optek_link_pairing_ch[OPTEK_LINK_PAIRING_MAX_CH] =
{
	//0,1,2,3,11,12					//test
    4,5,6,21,22,23
    //1,2,3,21,22,23				//ok
    //1,2,6,21,22,23
	//1,2,3
	//1,2,3
};

//based on application
//u32 optek_link_hopping_table_size_and_base_table_get(u8 *gen_table_size,u8 **base_table,u8 *base_table_size,u8 scan_f) __attribute__ ((section (".internal_ram_1_text")));  
u32 optek_link_hopping_table_size_and_base_table_get(u8 *gen_table_size,u8 **base_table,u8 *base_table_size,u8 scan_f)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
    if (scan_f)
        *gen_table_size = OPTEK_LINK_MAX_CH;
    else
        *gen_table_size = OPTEK_LINK_HOPPING_CH;

    *base_table = optek_link_scan_chan;
    *base_table_size = OPTEK_LINK_MAX_CH;
	#endif

    return 0;
}

#define OPTEK_LINK_CHAN_MASK	0x0FFFFFFF		//every channel can be used

//u32 optek_link20_hopping_table_size_and_base_table_get(u8 *gen_table_size,u8 **base_table,u8 *base_table_size,u32 *chan_mask,u8 scan_f) __attribute__ ((section (".internal_ram_1_text")));  
u32 optek_link20_hopping_table_size_and_base_table_get(u8 *gen_table_size,u8 **base_table,u8 *base_table_size,u32 *chan_mask,u8 scan_f)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
    if (scan_f)
        *gen_table_size = OPTEK_LINK_MAX_CH;
    else
        *gen_table_size = OPTEK_LINK_HOPPING_CH;

    *base_table = optek_link_scan_chan;
    *base_table_size = OPTEK_LINK_MAX_CH;
	*chan_mask = OPTEK_LINK_CHAN_MASK;
	#endif
    return 0;
}

/*
 * sync with source implementation
 ****************************************************************************************
 */
#if 1//def LOCAL_CLOCK_SYNC_WITH_AUDIO_SOURCE_ENABLE	
/*
 ****************************************************************************************
 * @brief calculate drift ratio between master and slave.
 *
 * @param[out]  driftR:  drift ratio,unit is ppm
 * 
 * @return status      1:success | 0:fail
 *
 ****************************************************************************************
 */
int optek_link_slave_cal_driftR(double *driftR)
{
    u32 base_cnt_rxsync_1st;
    u16 fine_cnt_rxsync_1st;
    u32  base_cnt_rxsync_last; 
    u16 fine_cnt_rxsync_last;
    i32 swap_cn;
 	i16 dyn_hus_cn_1st;
	i16 dyn_hus_cn_last;	

    u8 succ;
    i32 drift;
    u32 dis_hs;
    u32 abs_swap_hs;

    succ = optek_link_get_slave_time_sync_info (&base_cnt_rxsync_1st, &fine_cnt_rxsync_1st,
                                            &base_cnt_rxsync_last, &fine_cnt_rxsync_last,
                                            &swap_cn, &dyn_hus_cn_1st,&dyn_hus_cn_last, OPTEK_LINK_H1);

	//DBG_Printf("base last:%d,base 1st:%d,fine last:%d,fine 1st:%d,swap_cn:%d\n\r",base_cnt_rxsync_last,base_cnt_rxsync_1st,fine_cnt_rxsync_last,fine_cnt_rxsync_1st,swap_cn);

    //10ppm, 1s drift 20 (0.5us step), 10s drift 200 (0.5us step). therefore drift < 312 fro 10s test

	if (succ)
    {
        if (base_cnt_rxsync_last >= base_cnt_rxsync_1st)
            dis_hs = base_cnt_rxsync_last - base_cnt_rxsync_1st;
        else
            dis_hs = base_cnt_rxsync_last + 0x10000000- base_cnt_rxsync_1st;

		dis_hs = dis_hs*625 + fine_cnt_rxsync_last - fine_cnt_rxsync_1st;

		if (dis_hs < 1000000*2/625)
			return 0;


		drift = swap_cn*625 + fine_cnt_rxsync_last - fine_cnt_rxsync_1st;

        *driftR = (double) drift/(double)(dis_hs);

		return 1;
    }
	return 0;
}

/*
 ****************************************************************************************
 * @brief adjust master clock by drift ratio between audio source and local clock.
 *
 * @param[in]  driftR:  drift ratio,unit is ppm
 *
 ****************************************************************************************
 */
#if 0
void optek_link_master_clk_adj_by_driftR(double driftR)
{
	i8 step;
	U16 int_p;
	U32 frac_p;

	if (driftR == 0.0)
	{
		step = 0;
		int_p = 0;
		frac_p = 0;
	}
	else
	{
		driftR = 0.5 / (driftR*global_vari.frame_time_us);

		if (driftR < 0)
		{
			step = 1;
			driftR = -driftR;
		}
		else
		{
			step = -1;
		}

		while (driftR < 1.0)
		{
			driftR *= 2;
			step  *= 2;
			if (step == 4)
			{
				//driftR is too big,please check hardware, host or device?
				DBG_Assert(FALSE);
				DBG_printf("optek link dynamic sync error 1!\r\n");
				break;
			}
		}
		
		if (driftR >= 65536.0)
		{
			//driftR is too small,should not be here,please check software
			step = 0;
			int_p = 0;
			frac_p = 0;				
			DBG_Assert(FALSE);
			DBG_printf("driftR is too small,should not be here!\r\n");				
		}
		else
		{
			int_p = (U16)driftR;
			frac_p = (U32)((driftR - (double)int_p)*0x100000000L);
		}	
	}

	//DBG_printf("step:%d,int:%d,frac:%d\r\n",step,int_p,frac_p);	
	optek_link_set_master_tx_dynamic_sync(step,int_p,frac_p,OPTEK_LINK_H1);
}
#endif
#endif

/*
 * 
 ****************************************************************************************
 */

void bt_tx_disable (U8 disable) __attribute__ ((section (".internal_ram_1_text")));

void bt_tx_disable (U8 disable)
{
#ifdef BOOT_FROM_FLASH
	volatile U32 val;
	MISC_BTDM_2_CONTROLs *btdm_2_config;

	val = REG_MISC_BTDM_2;
	btdm_2_config = (MISC_BTDM_2_CONTROLs *) &val;
	
	btdm_2_config->bt_tx_disable = disable;

	REG_MISC_BTDM_2 = val;
#endif
}

#ifdef AUTO_CHANGE_MODE_ENABLE
/*
 * auto change mode,base on usb speaker uplink state
 ****************************************************************************************
 */
static U8 check_cnt = 0;
void optek_link_auto_change_mode_uplink_loop(void)
{

	if (optek_link_mode == BC_SF48K_PT5MS)
	{
		if (check_cnt++ > 2)
		{
			check_cnt = 0;		
			app_change_mode_req(GAME_HEADPHONE_PT_5MS_LP,100,60);
		}		
	}
	app_timer_usbdev_upstream_timeout_time_set(1000);		
}

void usbdev_upstream_timeout_handle(void)
{
	check_cnt = 0;
	if (GAME_HEADPHONE_PT_5MS_LP == optek_link_mode)
	{
		app_change_mode_req(BC_SF48K_PT5MS,100,6);
	}
}
#endif
/*
 * debug
 ****************************************************************************************
 */

#ifdef OPTEK_LINK_RX_QUALITY_DEBUG
U32 optek_link_rx_counters[enumTRANSMISSION_FAILED+1] = {0};

void optek_link_rx_quality_print(void)
{
	#ifdef OPTEK_LINK_FUNC_ENABLE
	int i;
	int max_retrans = enumTRANSMISSION_FAILED;

	if (global_vari.optek_link_role == OPL_ROLE_MASTER)
		return;

	for (i = enumTRANSMISSION_FAILED-1; i >= 0; i--)
	{
		if (0 == optek_link_rx_counters[i])
			max_retrans--;
		else
			break;
	}
	
	if (max_retrans)
	{
		printf_info("opl rx quality statistics:\n");
		printf_info("%-10s", "retrans");
		for (int i = 0; i < max_retrans; i++) {
			printf_info("%-10d", i);
		}

		if (optek_link_rx_counters[enumTRANSMISSION_FAILED])
		{
			printf_info("%-10s", "failed");
		}

		printf_info("\n");

		printf_info("%-10s", "counts");
		for (int i = 0; i < max_retrans; i++) {
			printf_info("%-10d", optek_link_rx_counters[i]);
		}
		if (optek_link_rx_counters[enumTRANSMISSION_FAILED])
		{
			printf_info("%-10d", optek_link_rx_counters[enumTRANSMISSION_FAILED]);
		}

		printf_info("\n\n");
	}
	#endif
}
#endif


void bt_break(void) __attribute__ ((section (".internal_ram_1_text")));
void bt_break(void)
{
#ifndef BOOT_FROM_FLASH 	
	asm("break 1,1");
#endif	
}


